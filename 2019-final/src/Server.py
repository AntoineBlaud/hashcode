from Item import Item
import json
import pickle
import collections
import random
from Node import Node
# 1) Ajouter la transformation de noeud en item sinon tout va buger
# 2) Ajouter multiple fichier dans placeNodeInBestPos
# 3) Modifier evalQuality dans main.py ( Pour loic)
# 4) Faire les fonctions non faites
# 5) Ecrire a la meme place

##copy node dans io !!!!!
class Server():

    def __init__(self,N = 1):

        #Create server store compilation step
        self.servers = []
        self.backupPath = "/home/darkloner99/code/Hashcode/Hashcode/2019-final/data/"
        #Number of servers
        self.N = N
        # All new node append are in aT, values of aT are rT+cT
        self.aT = {}
        #each server have a compiledTime save here
        self.times = []
        #All new node have a position referenced here in the a server
        self.pos = {}
        #All targets node are append here
        self.targets =  []
        #Each server is represented by a list
        for i in range(0,N):
            self.servers.append([])
            self.times.append(0)

        self.json_data = {"servers":self.servers,"aT":self.aT,"times":self.times,"pos":self.pos}
        self.QUOTA_1 = None
        self.QUOTA_2 = None
        


    def start(self,target:Node):
        '''
        Starting point function
        '''
        if(target.name not in self.targets):
            self.referenceServeur = self.chooseReferenceServer(target) #PROBLEME
            self.backup("backup_level_2.json")
            self.newRandomQuota()
            self.divisionProcess(target)
        
            
        
    def divisionProcess(self,target:Node):
        '''
        Subdivide, Subdivide graph until a leaf, place the leaf and goes back. Each step we use
        placeNodeInBestPosition to place the node
        '''
        # Available Time
        #Save procedeed target
        self.targets.append(target.name)
        cT = {}

        for node in target.childrens.values():
            cT[node] = self.evalGraph(node)
        cT = dict(sorted(cT.items(), key=lambda t: t[1],reverse=True))


        for node in cT.keys():
            self.divisionProcess(node)
        
        self.placeNodeInBestPosition(target)

        # call place target


    def placeNodeInBestPosition(self,node:Node):
        '''
        Place a node taking in account only process before childrens comp + rep
        Choose the server where the max(rep + compil) children's time is MAX
        '''

        fastest_server_time = self.getServeurWaitingTime(self.getFasterServerIndex())
        current_server_time = self.getServeurWaitingTime(self.referenceServeur)
        rT = node.packs["rT"]
        cT = node.packs["cT"]
        

        if(node.name not in self.aT.keys()):
    
            # If node is a leaf we place it where the waiting time is the min
            if(fastest_server_time+ rT < current_server_time):
                pos = self.getFasterServerIndex()
            else:
                pos = self.referenceServeur

            for children in node.childrens.values():
                if((self.aT[children.name])> current_server_time):
                    pos = self.getNodeServerPosition(children)
                    aT = self.aT[children.name]
            #Placer le noeud
            self.aT[node.name] = cT +  rT + self.getServeurWaitingTime(pos)
            self.pos[node.name] = pos
            self.place(node,pos)

        elif (self.aT[node.name] > random.randint(1,self.QUOTA_2)*(current_server_time + cT) and self.pos[node.name]!=self.referenceServeur):
            pos = self.referenceServeur
            self.aT[node.name] = cT +  rT + self.getServeurWaitingTime(pos)
            self.pos[node.name] = pos
             #Placer le noeud
            self.place(node,pos)
        

    
    
    def evalGraph(self,node:Node, visited={}):
        '''
        Return the time to compile all a graph on 1 Server
        '''
        T = 0
        for n in node.childrens.values():
            T+=self.evalGraph(n)
        return T+node.packs["rT"] 

    def getNodeServerPosition(self,node:Node):
        '''
        Get the current pos of a node (can be multiple), so return the fastest
        '''
        return self.pos[node.name]
 
    def evalTargetPoint(self,target:Item):
        '''
        Return profit of a target
        '''
        deadline = target.node.packs["deadline"]
        points = target.node.packs["points"]
        elapsedTime  = deadline - target.aTin
        if(elapsedTime >= 0):
            return points + elapsedTime
        return 0



    def evalTotalPoint(self):
        '''
        Return points generated by all servers and all targets in
        '''
        targets = {}
        TOTAL = 0
        for server in self.servers:
            for item in server:
                # Si le noeud est une target
                if(item.node.target):
                    points = self.evalTargetPoint(item)
                     # Si la target rapporte des points
                    if((points > 0)):
                        # Save target if it wasn't before or score is better
                        if((item.name not in targets.keys())):
                            targets[item.name] = points
                        elif((item.name in targets.keys()) and (targets[item.name] < points)):
                            targets[item.name] = points
        
        for v in targets.values():
            TOTAL+=v
        return TOTAL

                    
    def backup(self,filename):
        '''
        Save Save and recave to be lot of more efficient in combination tests
        '''
        with open(self.backupPath + filename, 'wb') as f:
            backup={"servers":self.servers,"aT":self.aT,"times":self.times,
            "pos":self.pos,"targets":self.targets}
            pickle.dump(backup,f)

    def restore(self,filename):
        with open(self.backupPath + filename, 'rb') as f:
            backup = pickle.load(f)
        #restore 
        self.servers = backup["servers"]
        self.aT = backup["aT"]
        self.times = backup ["times"]
        self.pos = backup["pos"]
        self.targets = backup["targets"]



    def getFasterServerIndex(self):
        '''
        Return the server whitch have the minimun waiting time
        '''
        #Defaults
        Min = self.times[0]
        bestServer = 0
        i = 0
        for waitingTime in self.times:
            if(waitingTime<Min):
                Min = waitingTime
                bestServer  = i
            i+=1
        return bestServer

    
    def getServeurWaitingTime(self,pos):
        return self.times[pos]
    
    def addServeurWaitingTime(self,pos,value):
        self.times[pos] += value

    def place(self,node:Node,pos):
        '''
        Place file on the server selected by pos and perform some important actions like 
        waiting time calculation 
        '''
        Max = 0
        Pos = 0
        timelapse = 0
        for child in node.childrens.values():
            if(self.aT[child.name]>Max):
                newMax = self.aT[child.name]
            if(pos == self.pos[child.name]):
                newMax-=child.packs["rT"]
            if(newMax > Max):
                Max  = newMax

        wait = self.getServeurWaitingTime(pos)
        if(Max-wait > 0):
            timelapse = Max - wait
        self.servers[pos].append(Item(node,max(Max,wait)))
        # Update Waiting time
        self.addServeurWaitingTime(pos,timelapse + node.packs["cT"])


    def chooseReferenceServer(self,target:Node):

        best = self.getFasterServerIndex()
        Max = 0
        score = 0
        i = 0
        for server in self.servers:
            for item in server:
                if(item.name in target):
                    score+=1
            if(score > Max and score > self.QUOTA_1):
                best = i
                score = 0

            i+=1
        return best

    def newRandomQuota(self):
        self.QUOTA_1 = random.randint(0,random.randint(1,200))
        self.QUOTA_2 = random.randint(1,random.randint(1,10))







    