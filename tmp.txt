/**
 * Notes:  
 * Un dico est transformé en tableau
 * Toutes les variables (int, float, etc) doivent être convertie en string dans le json
 * Profondeur max dico et tableau: 2
 * Si dico, mettre nom + valeur
 * 
 */

/* opened file */
FILE *f;
/* Current C charac */
char c;
/* crochet*/
int hook = 0;
/* accolade*/
int accolade = 0;
/* quote: 0 = fermé  1 = ouvert*/
int quote = 0;
/* Profondeur courante du json:*/
int depth = 0;

/* buffer pour lecture d'un nom de variable ou d'un valeur*/
char *buffer;
int bufferX = 0;
/* stocke nom + valeur*/
char ***json;
int jsonX = 0;
int jsonY = 0;
int jsonZ = 0;

/**
 * Enregistre une valeur de n'importe quel type (suivant la profondeur)
 */
void saveVarValue(void)
{
}

void applyNewDepth(int d)
{
    if (depth == 0 && d == 1)
    {
    }
    if (depth == 1 && d == 1)
    {
    }
    if (depth == 2 && d == 1)
    {
    }
    if (depth == 3 && d == 1)
    {
    }

    if (depth == 0 && d == -1)
    {
    }
    if (depth == 1 && d == -1)
    {
        jsonY += 1;
    }
    if (depth == 2 && d == -1)
    {
    }
    if (depth == 3 && d == -1)
    {
    }
}

/**
 * Enregistre le nom d'une variable, profondeur forcément égal à 1 car sinon c'est transformé en tableau
 */
void saveVarName(void)
{
    jsonX += 1;
    jsonY = 0;
    jsonZ = 0;
    json = (char ***)realloc(json, sizeof(char ***) * (jsonX + 1));
    json[jsonX] = (char **)realloc(json, sizeof(char **) * (jsonY + 1));
    json[jsonX][jsonY] = (char *)realloc(json, sizeof(char *) * (jsonZ + 1));
    json[jsonX][jsonY] = buffer;
}

/**
 * Incrémente juste le buffer
 */
void addCharToBuffer(void)
{
    bufferX += 1;
    buffer = (char *)realloc(buffer, sizeof(char *) * bufferX);
    buffer[bufferX - 1] = c;
    printf("Buffer:");
    printf("%s\n", buffer);
}

/**
 * Vérifie que ce soit un nom de variable
 */
int isName(void)
{
    while ((c = getc(f)) == ' ')
        continue;
    // On reviens 1 en arrière pour ne pas perde l'info si ce n'est pas un :
    if (c == ':')
        return 0;
    else
    {
        fseek(f, -1, SEEK_CUR);
        return 1;
    }
}

/**
 * Controleur principale du splitteur json
 * Faire carac spéciaux
 */
char **splitJsonFile(char *filename)
{
    /* Open the file*/
    if (f = fopen(filename, "rb"))
    {
        while ((c = getc(f)) != EOF)
        {
            switch (c)
            {
            case '"':
                /* Ouverture quote*/
                if (quote == 0)
                    quote = 1;
                else if (quote == 1 && isName() == 0 && depth == 1)
                {
                    quote = 0;
                    saveVarName();
                }

                else
                {
                    quote = 0;
                    saveVarValue();
                }
                break;
            case ' ':
                if (quote == 1)
                    addCharToBuffer();
                // Sinon ' ' existe juste pour le formatage et ne nous interresse pas
                break;
            // On doit incrémenter les jsoncX, etc..
            case '{':
                depth += 1;
                break;
            case '}':
                depth -= 1;
                break;
            case '[':
                depth += 1;
                break;
            case ']':
                depth -= 1;
                break;

            case 10:
                break;

            case 13:
                break;

            default:
                addCharToBuffer();
                break;
            }
        }
    }
}
